# useEffect

Reactコンポーネントは、**レンダリング**（UIの描画）だけでなく、データ取得やタイマー設定、イベントリスナーの設定などの**副作用**も扱います。`useEffect`フックは、これらの副作用処理を管理し、コンポーネントのライフサイクルに合わせたタイミングで実行できるようにする仕組みです。

---

## コンポーネントのライフサイクルと副作用

Reactのコンポーネントは、「**マウント（Mounting）**」「**更新（Updating）**」「**アンマウント（Unmounting）**」というライフサイクルの各段階において動作します。クラスコンポーネントでは、`componentDidMount`、`componentDidUpdate`、`componentWillUnmount`といったメソッドで処理を行っていましたが、React 16.8以降は関数コンポーネントでも**Hooks**を用いて同様の処理が可能になりました。

- **マウント**: コンポーネントが初めて描画されるタイミング  
- **更新**: 状態（state）やプロパティ（props）の変更で再レンダリングされるタイミング  
- **アンマウント**: コンポーネントが画面から削除されるタイミング  

`useEffect`は、これら各タイミングで副作用を実行したり、不要になった副作用の後処理（クリーンアップ）を行うために利用されます。

---

## `useEffect`の基本構文と使い方

`useEffect`は、関数コンポーネント内で次のように使用します。

```jsx
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // 副作用：例として、countの値をコンソールに出力
    console.log("Current count is...", count);

    // クリーンアップ関数（必要に応じて）
    return () => {
      console.log("Cleanup for count:", count);
    };
  });

  return (
    <div>
      <p>現在のカウント数: {count}</p>
      <button onClick={() => setCount(prev => prev + 1)}>Increment</button>
    </div>
  );
}
```

上記の例では、コンポーネントがレンダリングされるたびに`useEffect`が実行され、countの値がログに出力されます。また、必要に応じて後片付け用のクリーンアップ関数も定義できます。

---

## 依存配列（Dependency Array）による実行タイミングの制御

`useEffect`の第2引数として渡す**依存配列**により、副作用の実行タイミングを細かく制御できます。

### 1. **毎回実行**

依存配列を指定しない場合、コンポーネントのレンダリングごとに副作用が実行されます。

```jsx
useEffect(() => {
  console.log("毎回実行される副作用");
});
```

### 2. **初回レンダリング時のみ実行**

依存配列に空配列 `[]` を指定すると、コンポーネントが初めて描画された直後のみ副作用が実行されます。

```jsx
useEffect(() => {
  console.log("初回レンダリング後のみ実行");
}, []);
```

### 3. **特定の値が変更されたときに実行**

依存配列に特定の変数（例: `count`）を渡すと、その変数が変更されるたびに副作用が実行されます。

```jsx
useEffect(() => {
  console.log(`カウントが更新されました: ${count}`);
}, [count]);
```

また、複数の依存関係を指定すれば、いずれかが変わるたびに実行されます。

```jsx
useEffect(() => {
  console.log("複数の依存関係が変更されました");
}, [count, anotherValue]);
```

---

## クリーンアップ処理

副作用によっては、コンポーネントがアンマウントされる前や、次回副作用が実行される前に**クリーンアップ処理**が必要になる場合があります。`useEffect`内で関数を返すことで、これを実現できます。

例えば、タイマーの設定と解除を行う場合は以下のようになります。

```jsx
useEffect(() => {
  const timer = setInterval(() => {
    console.log('毎秒実行');
  }, 1000);

  // クリーンアップ関数：コンポーネントのアンマウント時にタイマーをクリア
  return () => clearInterval(timer);
}, []);
```

このパターンは、APIの購読解除やイベントリスナーの削除などにも応用できます。

---

## まとめ

- **`useEffect`とは**  
  副作用を管理するためのReactフックで、データの取得、イベントリスナーの設定、タイマー処理など、レンダリング以外の処理を行うために使用します。

- **ライフサイクルとの連携**  
  コンポーネントのマウント、更新、アンマウントといった各タイミングで副作用を実行・解除できる点が特徴です。

- **依存配列の役割**  
  第2引数の依存配列により、毎回実行、初回のみ実行、特定の変数変更時のみ実行といった柔軟な制御が可能になります。

- **クリーンアップ処理**  
  `useEffect`内で返す関数により、不要になった副作用の後片付けを確実に行うことができます。
